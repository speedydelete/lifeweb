
/** Finds the minimum and maximum rule of patterns. */

import {RuleError, Pattern, CoordPattern} from './pattern.js';
import {TRANSITIONS, VALID_TRANSITIONS, HEX_TRANSITIONS, VALID_HEX_TRANSITIONS, arrayToTransitions, unparseTransitions, unparseMAP, MAPPattern, MAPB0Pattern, MAPGenPattern, MAPGenB0Pattern} from './map.js';
import {unparseHROTRanges, HROTPattern, HROTB0Pattern} from './hrot.js';
import {AlternatingPattern} from './alternating.js';
import {TreePattern} from './ruleloader.js';


/** Stores information about the phases of a pattern. */
export interface PhaseData {
    /** The populations of each generation. */
    pops: number[];
    /** The 32-bit hash generated by `hash32` for each phase. */
    hashes: number[];
    /** Data for each generation. */
    phases: Pattern[];
}


/** Verifies that a pattern is consistent with a given `PhaseData`. */
function verifyType(p: Pattern, data: PhaseData, gens: number, step: number): boolean {
    for (let i = 0; i <= gens; i++) {
        if (p.hash32() !== data.hashes[i] || p.population !== data.pops[i]) {
            return false;
        }
        if (!(p instanceof CoordPattern ? p.isEqualWithTranslate(data.phases[i]) : p.isEqual(data.phases[i]))) {
            return false;
        }
        p.run(step);
        p.shrinkToFit();
    }
    return true;
}

/** Finds minimum and maximum rules for patterns in non-B0 isotropic rules
 * @param allTrs Generally either `TRANSITIONS` or `HEX_TRANSITIONS`.
 */
function isotropicMinmax(p: MAPPattern | MAPGenPattern, data: PhaseData, gens: number, step: number, allTrs: {[key: string]: number[]}): {minB: string[], minS: string[], maxB: string[], maxS: string[]} {
    let [b, s] = arrayToTransitions(p.trs, allTrs);
    let minB = new Set(b);
    let minS = new Set(s);
    let maxB = new Set(b);
    let maxS = new Set(s);
    for (let tr in allTrs) {
        let q = p.copy();
        q.trs = q.trs.slice();
        if (tr !== '0c') {
            if (minB.has(tr)) {
                for (let i of allTrs[tr]) {
                    q.trs[i] = 0;
                }
                if (verifyType(q, data, gens, step)) {
                    minB.delete(tr);
                }
            } else {
                for (let i of allTrs[tr]) {
                    q.trs[i] = 1;
                }
                if (verifyType(q, data, gens, step)) {
                    maxB.add(tr);
                }
            }
            q = p.copy();
            q.trs = q.trs.slice();
        }
        if (minS.has(tr)) {
            for (let i of allTrs[tr]) {
                q.trs[i | (1 << 4)] = 0;
            }
            if (verifyType(q, data, gens, step)) {
                minS.delete(tr);
            }
        } else {
            for (let i of allTrs[tr]) {
                q.trs[i | (1 << 4)] = 1;
            }
            if (verifyType(q, data, gens, step)) {
                maxS.add(tr);
            }
        }
    }
    return {
        minB: Array.from(minB),
        minS: Array.from(minS),
        maxB: Array.from(maxB),
        maxS: Array.from(maxS),
    };
}

/** Finds minimum and maximum rules for patterns in B0 isotropic rules
 * @param allTrs Generally either `TRANSITIONS` or `HEX_TRANSITIONS`.
 */
function isotropicB0Minmax(p: MAPB0Pattern | MAPGenB0Pattern, data: PhaseData, gens: number, step: number, allTrs: {[key: string]: number[]}): {minB: string[], minS: string[], maxB: string[], maxS: string[]} {
    let [b, s] = arrayToTransitions(p.evenTrs.map(x => 1 - x), allTrs);
    b.push('0c');
    let minB = new Set(b);
    let minS = new Set(s);
    let maxB = new Set(b);
    let maxS = new Set(s);
    for (let tr in allTrs) {
        if (tr !== '0c') {
            let q = p.copy();
            q.evenTrs = q.evenTrs.slice();
            q.oddTrs = q.oddTrs.slice();
            if (minB.has(tr)) {
                for (let i of allTrs[tr]) {
                    q.evenTrs[i] = 1;
                    q.oddTrs[511 - i] = 0;
                }
                if (verifyType(q, data, gens, step)) {
                    minB.delete(tr);
                }
            } else {
                for (let i of allTrs[tr]) {
                    q.evenTrs[i] = 0;
                    q.oddTrs[511 - i] = 1;
                }
                if (verifyType(q, data, gens, step)) {
                    maxB.add(tr);
                }
            }
        }
        if (tr !== '8c') {
            let q = p.copy();
            q.evenTrs = q.evenTrs.slice();
            q.oddTrs = q.oddTrs.slice();
            if (minS.has(tr)) {
                for (let i of allTrs[tr]) {
                    q.evenTrs[i | (1 << 4)] = 1;
                    q.oddTrs[511 - (i | (1 << 4))] = 0;
                }
                if (verifyType(q, data, gens, step)) {
                    minS.delete(tr);
                }
            } else {
                for (let i of allTrs[tr]) {
                    q.evenTrs[i | (1 << 4)] = 0;
                    q.oddTrs[511 - (i | (1 << 4))] = 1;
                }
                if (verifyType(q, data, gens, step)) {
                    maxS.add(tr);
                }
            }
        }
    }
    return {
        minB: Array.from(minB),
        minS: Array.from(minS),
        maxB: Array.from(maxB),
        maxS: Array.from(maxS),
    };
}

/** Finds minimum and maximum rules for MAP string rules (https://conwaylife.com/wiki/Non-isotropic_rule). */
function mapStringMinmax(p: MAPPattern | MAPGenPattern, data: PhaseData, gens: number, step: number): [string, string] {
    let min = p.trs.slice();
    let max = p.trs.slice();
    for (let i = 0; i < 512; i++) {
        let q = p.copy();
        q.trs[i] = 1 - q.trs[i];
        if (verifyType(q, data, gens, step)) {
            if (q.trs[i]) {
                min[i] = 0;
            } else {
                max[i] = 1;
            }
        }
        q.trs[i] = 1 - q.trs[i];
    }
    return [unparseMAP(min), unparseMAP(max)];
}

/** Finds minimum and maximum rules for MAP string rules (https://conwaylife.com/wiki/Non-isotropic_rule) with B0. */
function mapB0StringMinmax(p: MAPB0Pattern | MAPGenB0Pattern, data: PhaseData, gens: number, step: number): [string, string] {
    let min = p.evenTrs.map(x => 1 - x);
    let max = p.evenTrs.map(x => 1 - x);
    for (let i = 0; i < 512; i++) {
        let q = p.copy();
        q.evenTrs[i] = 1 - q.evenTrs[i];
        q.oddTrs[511 - i] = 1 - q.oddTrs[511 - i];
        if (verifyType(q, data, gens, step)) {
            if (q.evenTrs[i]) {
                min[i] = 1;
            } else {
                max[i] = 0;
            }
        }
        q.evenTrs[i] = 1 - q.evenTrs[i];
        q.oddTrs[511 - i] = 1 - q.oddTrs[511 - i];
    }
    return [unparseMAP(min), unparseMAP(max)];
}

/** Finds minimum and maximum rules for patterns in the 2**512 2-state range-1 Moore-neighborhood rules. */
function mapMinmax(p: MAPPattern | MAPB0Pattern | MAPGenPattern | MAPGenB0Pattern, data: PhaseData, gens: number, step: number): [string, string] {
    p.shrinkToFit();
    let minB: string;
    let minS: string;
    let maxB: string;
    let maxS: string;
    let out: ReturnType<typeof isotropicMinmax>;
    if (p.ruleStr.endsWith('H')) {
        if (p instanceof MAPPattern || p instanceof MAPGenPattern) {
            out = isotropicMinmax(p, data, gens, step, HEX_TRANSITIONS);
        } else {
            out = isotropicB0Minmax(p, data, gens, step, HEX_TRANSITIONS);
        }
        minB = unparseTransitions(out.minB, VALID_HEX_TRANSITIONS, true);
        minS = unparseTransitions(out.minS, VALID_HEX_TRANSITIONS, true);
        maxB = unparseTransitions(out.maxB, VALID_HEX_TRANSITIONS, true);
        maxS = unparseTransitions(out.maxS, VALID_HEX_TRANSITIONS, true);
    } else if (p.ruleStr.startsWith('MAP')) {
        let min: string, max: string;
        if (p instanceof MAPPattern || p instanceof MAPGenPattern) {
            [min, max] = mapStringMinmax(p, data, gens, step);
        } else {
            [min, max] = mapB0StringMinmax(p, data, gens, step);
        }
        if (p instanceof MAPGenPattern) {
            min += '/' + p.states;
            max += '/' + p.states;
        }
        return [min, max];
    } else {
        if (p instanceof MAPPattern || p instanceof MAPGenPattern) {
            out = isotropicMinmax(p, data, gens, step, TRANSITIONS);
        } else {
            out = isotropicB0Minmax(p, data, gens, step, TRANSITIONS);
        }
        minB = unparseTransitions(out.minB, VALID_TRANSITIONS);
        minS = unparseTransitions(out.minS, VALID_TRANSITIONS);
        maxB = unparseTransitions(out.maxB, VALID_TRANSITIONS);
        maxS = unparseTransitions(out.maxS, VALID_TRANSITIONS);
    }
    let min: string;
    let max: string;
    if (p instanceof MAPPattern || p instanceof MAPB0Pattern) {
        min = `B${minB}/S${minS}`;
        max = `B${maxB}/S${maxS}`;
    } else {
        min = `${minS}/${minB}/${p.states}`;
        max = `${maxS}/${maxB}/${p.states}`;
    }
    if (p.ruleStr.endsWith('H')) {
        min += 'H';
        max += 'H';
    }
    return [min, max];
}

/** Finds minimum and maximum rules for patterns in OT non-B0 rules. */
function otMinmax(p: MAPPattern | MAPGenPattern, minB: number[], minS: number[], data: PhaseData, gens: number, step: number, allTrs: {[key: string]: number[]}, validTrs: string[]): [number[], number[], number[], number[]] {
    let maxB = minB.slice();
    let maxS = minS.slice();
    for (let i = 0; i < validTrs.length; i++) {
        let q = p.copy();
        q.trs = q.trs.slice();
        if (i !== 0) {
            if (minB.includes(i)) {
                for (let letter of validTrs[i]) {
                    for (let tr of allTrs[i + letter]) {
                        q.trs[tr] = 0;
                    }
                }
                if (verifyType(q, data, gens, step)) {
                    minB.splice(minB.indexOf(i), 1);
                }
            } else {
                for (let letter of validTrs[i]) {
                    for (let tr of allTrs[i + letter]) {
                        q.trs[tr] = 1;
                    }
                }
                if (verifyType(q, data, gens, step)) {
                    maxB.push(i);
                }
            }
            q = p.copy();
            q.trs = q.trs.slice();
        }
        if (minS.includes(i)) {
            for (let letter of validTrs[i]) {
                for (let tr of allTrs[i + letter]) {
                    q.trs[tr | (1 << 4)] = 0;
                }
            }
            if (verifyType(q, data, gens, step)) {
                minS.splice(minS.indexOf(i), 1);
            }
        } else {
            for (let letter of validTrs[i]) {
                for (let tr of allTrs[i + letter]) {
                    q.trs[tr | (1 << 4)] = 1;
                }
            }
            if (verifyType(q, data, gens, step)) {
                maxS.push(i);
            }
        }
    }
    return [minB, minS, maxB, maxS];
}

/** Finds minimum and maximum rules for patterns in OT B0 rules. */
function otB0Minmax(p: MAPB0Pattern | MAPGenB0Pattern, minB: number[], minS: number[], data: PhaseData, gens: number, step: number, allTrs: {[key: string]: number[]}, validTrs: string[]): [number[], number[], number[], number[]] {
    let maxB = minB.slice();
    let maxS = minS.slice();
    for (let i = 0; i < validTrs.length; i++) {
        if (i !== 0) {
            let q = p.copy();
            q.evenTrs = q.evenTrs.slice();
            q.oddTrs = q.oddTrs.slice();
            if (minB.includes(i)) {
                for (let letter of validTrs[i]) {
                    for (let tr of allTrs[i + letter]) {
                        q.evenTrs[tr] = 1;
                        q.oddTrs[511 - tr] = 0;
                    }
                }
                if (verifyType(q, data, gens, step)) {
                    minB.splice(minB.indexOf(i), 1);
                }
            } else {
                for (let letter of validTrs[i]) {
                    for (let tr of allTrs[i + letter]) {
                        q.evenTrs[tr] = 0;
                        q.oddTrs[511 - tr] = 1;
                    }
                }
                if (verifyType(q, data, gens, step)) {
                    maxB.push(i);
                }
            }
        }
        if (i !== 8) {
            let q = p.copy();
            q.evenTrs = q.evenTrs.slice();
            q.oddTrs = q.oddTrs.slice();
            if (minS.includes(i)) {
                for (let letter of validTrs[i]) {
                    for (let tr of allTrs[i + letter]) {
                        q.evenTrs[tr | (1 << 4)] = 1;
                        q.oddTrs[511 - (tr | (1 << 4))] = 0;
                    }
                }
                if (verifyType(q, data, gens, step)) {
                    minS.splice(minS.indexOf(i), 1);
                }
            } else {
                for (let letter of validTrs[i]) {
                    for (let tr of allTrs[i + letter]) {
                        q.evenTrs[tr | (1 << 4)] = 0;
                        q.oddTrs[511 - (tr | (1 << 4))] = 1;
                    }
                }
                if (verifyType(q, data, gens, step)) {
                    maxS.push(i);
                }
            }
        }
    }
    return [minB, minS, maxB, maxS];
}

/** Finds minimum and maximum rules for patterns in OT rules. */
function fullOTMinmax(p: MAPPattern | MAPB0Pattern | MAPGenPattern | MAPGenB0Pattern, data: PhaseData, gens: number, step: number): [string, string] {
    let isHex = p.ruleStr.endsWith('H');
    let allTrs = isHex ? HEX_TRANSITIONS : TRANSITIONS;
    let validTrs = isHex ? VALID_HEX_TRANSITIONS : VALID_TRANSITIONS;
    if (isHex ? p.ruleSymmetry === 'D4x' : p.ruleSymmetry !== 'D8') {
        throw new Error(`Pattern must be in [Hexagonal] [Generations] [B0] INT for outer-totalistic minmax`);
    }
    let startB: number[] = [];
    let startS: number[] = [];
    let trs = 'trs' in p ? p.trs : p.evenTrs.map(x => 1 - x);
    for (let i = 0; i <= (isHex ? 6 : 8); i++) {
        let bFound = true;
        let sFound = true;
        for (let letter of validTrs[i]) {
            if (!trs[allTrs[i + letter][0]]) {
                bFound = false;
            }
            if (!trs[allTrs[i + letter][0] | (1 << 4)]) {
                sFound = false;
            }
        }
        if (bFound) {
            startB.push(i);
        }
        if (sFound) {
            startS.push(i);
        }
    }
    let outData: number[][] = [];
    if (p instanceof MAPPattern || p instanceof MAPGenPattern) {
        outData = otMinmax(p, startB, startS, data, gens, step, allTrs, validTrs);
    } else {
        outData = otB0Minmax(p, startB, startS, data, gens, step, allTrs, validTrs);
    }
    let [minB, minS, maxB, maxS] = outData.map(x => x.sort((x, y) => x - y).join(''));
    if (p instanceof MAPPattern || p instanceof MAPB0Pattern) {
        return [`B${minB}/S${minS}`, `B${maxB}/S${maxS}`];
    } else {
        return [`${minS}/${minB}/${p.states}`, `${maxS}/${maxB}/${p.states}`];
    }
}

/** Finds minimum and maximum rules for patterns in HROT rules without B0. */
function hrotMinmax(p: HROTPattern, data: PhaseData, gens: number, step: number): [string, string] {
    let parts = p.ruleStr.split(',');
    let min = `${parts[0]},${parts[1]},S`;
    let max = `${parts[0]},${parts[1]},S`;
    let minS = p.s.slice();
    let maxS = p.s.slice();
    for (let i = 0; i < minS.length; i++) {
        if (minS[i]) {
            p.s[i] = 0;
            if (verifyType(p, data, gens, step)) {
                minS[i] = 0;
            }
            p.s[i] = 1;
        } else {
            p.s[i] = 1;
            if (verifyType(p, data, gens, step)) {
                maxS[i] = 1;
            }
            p.s[i] = 0;
        }
    }
    min += unparseHROTRanges(minS) + ',B';
    max += unparseHROTRanges(maxS) + ',B';
    let minB = p.b.slice();
    let maxB = p.b.slice();
    for (let i = 1; i < minB.length; i++) {
        if (minB[i]) {
            p.b[i] = 0;
            if (verifyType(p, data, gens, step)) {
                minB[i] = 0;
            }
            p.b[i] = 1;
        } else {
            p.b[i] = 1;
            if (verifyType(p, data, gens, step)) {
                maxB[i] = 1;
            }
            p.b[i] = 0;
        }
    }
    min += unparseHROTRanges(minB);
    max += unparseHROTRanges(maxB);
    if (parts.length === 5) {
        min += ',' + parts[4];
        max += ',' + parts[4];
    }
    return [min, max];
}

/** Finds minimum and maximum rules for patterns in HROT rules with B0. */
function hrotB0Minmax(p: HROTB0Pattern, data: PhaseData, gens: number, step: number): [string, string] {
    let parts = p.ruleStr.split(',');
    let min = `${parts[0]},${parts[1]},S`;
    let max = `${parts[0]},${parts[1]},S`;
    let minS = p.evenS.map(x => 1 - x);
    let maxS = p.evenS.map(x => 1 - x);
    for (let i = 0; i < minS.length; i++) {
        if (minS[i]) {
            p.evenS[i] = 1;
            p.oddS[minS.length - 1 - i] = 0;
            if (verifyType(p, data, gens, step)) {
                minS[i] = 0;
            }
            p.evenS[i] = 0;
            p.oddS[minS.length - 1 - i] = 1;
        } else {
            p.evenS[i] = 0;
            p.oddS[minS.length - 1 - i] = 1;
            if (verifyType(p, data, gens, step)) {
                maxS[i] = 1;
            }
            p.evenS[i] = 1;
            p.oddS[minS.length - 1 - i] = 0;
        }
    }
    min += unparseHROTRanges(minS) + ',B';
    max += unparseHROTRanges(maxS) + ',B';
    let minB = p.evenB.map(x => 1 - x);
    let maxB = p.evenB.map(x => 1 - x);
    for (let i = 0; i < minB.length; i++) {
        if (minB[i]) {
            p.evenB[i] = 1;
            p.oddB[minB.length - 1 - i] = 0;
            if (verifyType(p, data, gens, step)) {
                minB[i] = 0;
            }
            p.evenB[i] = 0;
            p.oddB[minB.length - 1 - i] = 1;
        } else {
            p.evenB[i] = 0;
            p.oddB[minB.length - 1 - i] = 1;
            if (verifyType(p, data, gens, step)) {
                maxB[i] = 1;
            }
            p.evenB[i] = 1;
            p.oddB[minB.length - 1 - i] = 0;
        }
    }
    min += unparseHROTRanges(minB);
    max += unparseHROTRanges(maxB);
    if (parts.length === 5) {
        min += ',' + parts[4];
        max += ',' + parts[4];
    }
    return [min, max];
}

/** Finds minimum and maximum rules for patterns in alternating-time rules. */
function alternatingMinmax(p: AlternatingPattern, data: PhaseData, gens: number, step: number, ot?: boolean): [string, string] {
    let min: string[] = [];
    let max: string[] = [];
    let count = p.patterns.length * step;
    for (let i = 0; i < count; i += step) {
        let q = p.patterns[i % p.patterns.length].copy();
        let phase = data.phases[i] as AlternatingPattern;
        q.setData(phase.height, phase.width, phase.data);
        let newData: PhaseData = {pops: [], hashes: [], phases: []};
        for (let j = i; j < gens; j += count) {
            newData.pops.push(data.pops[j]);
            newData.hashes.push(data.hashes[j]);
            newData.phases.push(data.phases[j]);
        }
        let minmax = findMinmax(q, Math.floor((gens - i) / count), newData, count, ot);
        min.push(minmax[0]);
        max.push(minmax[1]);
    }
    return [min.join('|'), max.join('|')];
}

/** Finds minimum and maximum rules for patterns for a given number of generations.
 * @param data An optional `PhaseData` to take place of the auto-generated one.
 * @param step The step used while running patterns, used internally.
 * @param ot Whether to use outer-totalistic minmax instead of isotropic minmax when available.
*/
export function findMinmax(p: Pattern, gens: number, data?: PhaseData, step: number = 1, ot?: boolean): [string, string] {
    p = p.copy().shrinkToFit();
    if (data === undefined) {
        let pops: number[] = [p.population];
        let hashes: number[] = [p.hash32()];
        let phases: Pattern[] = [p.copy()];
        let q = p.copy();
        for (let i = 0; i < gens + 1; i++) {
            q.run(step);
            q.shrinkToFit();
            pops.push(q.population);
            hashes.push(q.hash32());
            phases.push(q.copy());
        }
        data = {pops, hashes, phases};
    } else {
        let q = data.phases[data.phases.length - 1].copy();
        q.run(step);
        q.shrinkToFit();
        data.pops.push(q.population);
        data.hashes.push(q.hash32());
        data.phases.push(q);
    }
    if (p instanceof MAPPattern || p instanceof MAPGenPattern || p instanceof MAPB0Pattern || p instanceof MAPGenB0Pattern) {
        if (ot && p.ruleSymmetry === 'D8') {
            return fullOTMinmax(p, data, gens, step);
        } else {
            return mapMinmax(p, data, gens, step);
        }
    } else if (p instanceof HROTPattern) {
        return hrotMinmax(p, data, gens, step);
    } else if (p instanceof HROTB0Pattern) {
        return hrotB0Minmax(p, data, gens, step);
    } else if (p instanceof AlternatingPattern) {
        return alternatingMinmax(p, data, gens, step, ot);
    } else if (p instanceof TreePattern) {
        return [p.ruleStr, p.ruleStr];
    } else {
        throw new RuleError(`Unknown pattern: ${p.constructor.name}`);
    }
}
